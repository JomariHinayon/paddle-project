{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/elevate/newPaddle/src/app/api/webhook/paddle/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport crypto from 'crypto';\nimport admin from 'firebase-admin';\n\n// Helper function to handle private key formatting\n\nconst getFirebaseCredential = () => {\n  if (process.env.FIREBASE_PRIVATE_KEY) {\n    let privateKey = process.env.FIREBASE_PRIVATE_KEY;\n\n    // Option 1: If stored with \\n\n    if (privateKey.includes('\\\\n')) {\n      privateKey = privateKey.replace(/\\\\n/g, '\\n');\n    }\n\n    // Option 2: If stored as base64\n    if (isBase64(privateKey)) {\n      try {\n        privateKey = Buffer.from(privateKey, 'base64').toString('utf-8');\n      } catch (error) {\n        console.error('Error decoding base64 private key:', error);\n        throw new Error('Could not decode base64 Firebase private key.');\n      }\n    }\n\n    // Final check and formatting to ensure PEM structure\n    if (!privateKey.includes('-----BEGIN PRIVATE KEY-----') || !privateKey.includes('-----END PRIVATE KEY-----')) {\n      console.error('Invalid private key format: Missing BEGIN or END markers.');\n      throw new Error('Invalid Firebase private key format.');\n    }\n\n    // Ensure internal newlines for the base64 part\n    const lines = privateKey.split('\\n');\n    const beginLineIndex = lines.findIndex(line => line.includes('-----BEGIN PRIVATE KEY-----'));\n    const endLineIndex = lines.findIndex(line => line.includes('-----END PRIVATE KEY-----'));\n\n    if (beginLineIndex !== -1 && endLineIndex !== -1 && endLineIndex > beginLineIndex + 1) {\n      const keyLines = lines.slice(beginLineIndex + 1, endLineIndex);\n      const formattedKeyLines = keyLines.map(line => line.trim()).join('');\n      let formattedKey = lines.slice(0, beginLineIndex + 1).join('\\n') + '\\n';\n      for (let i = 0; i < formattedKeyLines.length; i += 64) {\n        formattedKey += formattedKeyLines.substring(i, i + 64) + '\\n';\n      }\n      formattedKey += lines.slice(endLineIndex).join('\\n');\n      privateKey = formattedKey.trim(); // Trim any trailing newline\n    }\n\n\n    console.log('Using private key (first 20 chars):', privateKey.substring(0, 20) + '...');\n\n    return admin.credential.cert({\n      projectId: process.env.FIREBASE_PROJECT_ID,\n      clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n      privateKey: privateKey,\n    });\n  }\n\n  throw new Error('Firebase private key not found in environment variables.');\n};\n\n// Helper function to check if a string is likely base64 encoded\nfunction isBase64(str: string) {\n  try {\n    return Buffer.from(str, 'base64').toString('base64') === str;\n  } catch (e) {\n    return false;\n  }\n}\n\n// Initialize Firebase Admin if not already initialized\nif (!admin.apps.length) {\n  admin.initializeApp({\n    credential: getFirebaseCredential(),\n  });\n}\n\nconst db = admin.firestore();\n\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n};\n\nconst verifyPaddleSignature = (rawBody: string, signature: string) => {\n  try {\n    const publicKey = process.env.PADDLE_PUBLIC_KEY;\n    if (!publicKey) {\n      console.error('Paddle public key not configured in environment variables');\n      return false;\n    }\n\n    // For debugging: log the signature received\n    console.log(`Received signature: ${signature}`);\n    \n    // In development/testing mode, you can bypass signature verification\n    if (process.env.NODE_ENV === 'development' && process.env.BYPASS_PADDLE_VERIFICATION === 'true') {\n      console.log('Bypassing signature verification in development mode');\n      return true;\n    }\n\n    // Use the key directly for HMAC calculation - Paddle's simple API uses HMAC-SHA256\n    const hmacHash = crypto.createHmac('sha256', publicKey).update(rawBody).digest('hex');\n    const result = hmacHash === signature;\n    \n    console.log(`Signature verification: ${result ? 'Success' : 'Failed'}`);\n    console.log(`Calculated hash (first 10 chars): ${hmacHash.substring(0, 10)}...`);\n    console.log(`Expected signature (first 10 chars): ${signature.substring(0, 10)}...`);\n\n    return result;\n  } catch (error) {\n    console.error('Error verifying Paddle signature:', error);\n    return false;\n  }\n};\n\nexport async function POST(req: Request) {\n  try {\n    // Read the raw body\n    const rawBody = await req.text();\n    const url = new URL(req.url);\n    \n    // Check if this is a test endpoint\n    if (url.pathname.includes('/test')) {\n      console.log('TEST WEBHOOK - Headers:', JSON.stringify(Object.fromEntries([...req.headers])));\n      console.log('TEST WEBHOOK - Raw Body:', rawBody);\n      \n      try {\n        // Try to parse the body as JSON\n        const jsonBody = JSON.parse(rawBody);\n        console.log('TEST WEBHOOK - Parsed JSON:', JSON.stringify(jsonBody, null, 2));\n      } catch (e) {\n        console.log('TEST WEBHOOK - Not valid JSON');\n      }\n      \n      // Always return success for testing\n      return NextResponse.json({ \n        status: 'success',\n        message: 'Test webhook received and logged'\n      });\n    }\n    \n    // Production webhook handling\n    const signature = req.headers.get('paddle-signature');\n\n    console.log('Incoming webhook payload:', rawBody);\n    console.log('Webhook headers:', JSON.stringify(Object.fromEntries([...req.headers])));\n\n    // During initial setup or troubleshooting, you can temporarily allow webhooks without verification\n    const bypassVerification = process.env.NODE_ENV === 'development' && process.env.BYPASS_PADDLE_VERIFICATION === 'true';\n    \n    if (!signature) {\n      console.error('No paddle-signature header found');\n      return NextResponse.json({ message: 'Missing signature header' }, { status: 401 });\n    }\n    \n    if (!bypassVerification && !verifyPaddleSignature(rawBody, signature)) {\n      console.error('Signature verification failed');\n      \n      // During testing/development, you can still process the webhook even if verification fails\n      if (process.env.NODE_ENV === 'development' && process.env.PROCESS_INVALID_SIGNATURES === 'true') {\n        console.log('Processing webhook despite failed verification (development mode)');\n      } else {\n        return NextResponse.json({ message: 'Invalid signature' }, { status: 401 });\n      }\n    }\n    \n    const { event_type, data } = JSON.parse(rawBody);\n    const normalizedEvent = event_type.replace('.', '_');\n\n    console.log(`Processing Paddle ${event_type} event`, { data: JSON.stringify(data) });\n\n    // Log the specific event type and data for debugging\n    console.log(`Received Paddle webhook event: ${event_type}`);\n    console.log(`Event data:`, JSON.stringify(data, null, 2));\n\n    // Process different types of webhook events\n    switch (normalizedEvent) {\n      case 'subscription_created':\n        await handleSubscriptionCreated(data);\n        break;\n      case 'subscription_updated':\n        await handleSubscriptionUpdated(data);\n        break;\n      case 'subscription_canceled':\n        await handleSubscriptionCanceled(data);\n        break;\n      case 'subscription_payment_succeeded':\n        await handleSubscriptionPaymentSucceeded(data);\n        break;\n      case 'subscription_payment_failed':\n        await handleSubscriptionPaymentFailed(data);\n        break;\n      case 'checkout_completed':\n        await handleCheckoutCompleted(data);\n        break;\n      default:\n        console.log(`Unhandled event type: ${event_type}`);\n    }\n\n    return NextResponse.json({ message: 'Webhook processed successfully' }, { status: 200 });\n  } catch (error) {\n    console.error('Webhook Error:', error);\n    return NextResponse.json({ message: 'Webhook processing failed' }, { status: 400 });\n  }\n}\n\n// Handler for subscription.created events\nasync function handleSubscriptionCreated(data: any) {\n  try {\n    const userId = await getUserIdFromSubscriptionData(data);\n    const subscriptionId = data.id;\n    \n    if (!userId) {\n      console.error('Could not determine userId for subscription:', subscriptionId);\n      return;\n    }\n\n    // Extract and format subscription data\n    const subscriptionData = formatSubscriptionData(data);\n    \n    // Create/update subscription document in Firestore\n    // Use subscriptionId as the document ID for easy lookups\n    const subscriptionRef = db.collection('subscriptions').doc(subscriptionId);\n    await subscriptionRef.set({\n      ...subscriptionData,\n      userId, // Associate with user\n      createdAt: admin.firestore.FieldValue.serverTimestamp(),\n      updatedAt: admin.firestore.FieldValue.serverTimestamp(),\n    });\n    \n    // Also store a reference in the user's subscriptions collection\n    const userSubscriptionRef = db.collection('users').doc(userId).collection('subscriptions').doc(subscriptionId);\n    await userSubscriptionRef.set({\n      ...subscriptionData,\n      createdAt: admin.firestore.FieldValue.serverTimestamp(),\n      updatedAt: admin.firestore.FieldValue.serverTimestamp(),\n    });\n    \n    // Update user document with active subscription status\n    const userRef = db.collection('users').doc(userId);\n    await userRef.set({\n      hasActiveSubscription: true,\n      currentSubscriptionId: subscriptionId,\n      subscriptionStatus: subscriptionData.status,\n      currentPlan: subscriptionData.planId,\n      nextBillDate: subscriptionData.nextBillDate,\n      paddleCustomerId: subscriptionData.customerId,\n      lastUpdated: admin.firestore.FieldValue.serverTimestamp()\n    }, { merge: true });\n    \n    console.log(`Subscription created and saved to Firestore. SubscriptionId: ${subscriptionId}, UserId: ${userId}`);\n  } catch (error) {\n    console.error('Error handling subscription.created event:', error);\n    throw error;\n  }\n}\n\n// Handler for subscription.updated events\nasync function handleSubscriptionUpdated(data: any) {\n  try {\n    const subscriptionId = data.id;\n    \n    // Check if the subscription already exists\n    const subscriptionRef = db.collection('subscriptions').doc(subscriptionId);\n    const subscriptionDoc = await subscriptionRef.get();\n    \n    if (!subscriptionDoc.exists) {\n      console.log(`Subscription ${subscriptionId} not found, treating as new subscription`);\n      return await handleSubscriptionCreated(data);\n    }\n    \n    const existingData = subscriptionDoc.data();\n    const userId = existingData?.userId || await getUserIdFromSubscriptionData(data);\n    \n    if (!userId) {\n      console.error('Could not determine userId for subscription update:', subscriptionId);\n      return;\n    }\n    \n    // Extract and format updated subscription data\n    const subscriptionData = formatSubscriptionData(data);\n    \n    // Update subscription document\n    await subscriptionRef.set({\n      ...subscriptionData,\n      userId,\n      updatedAt: admin.firestore.FieldValue.serverTimestamp(),\n    }, { merge: true });\n    \n    // Update the user's subscription reference\n    const userSubscriptionRef = db.collection('users').doc(userId).collection('subscriptions').doc(subscriptionId);\n    await userSubscriptionRef.set({\n      ...subscriptionData,\n      updatedAt: admin.firestore.FieldValue.serverTimestamp(),\n    }, { merge: true });\n    \n    // Update user document with the latest subscription info\n    const userRef = db.collection('users').doc(userId);\n    await userRef.set({\n      currentSubscriptionId: subscriptionId,\n      subscriptionStatus: subscriptionData.status,\n      currentPlan: subscriptionData.planId,\n      nextBillDate: subscriptionData.nextBillDate,\n      lastUpdated: admin.firestore.FieldValue.serverTimestamp()\n    }, { merge: true });\n    \n    console.log(`Subscription updated in Firestore. SubscriptionId: ${subscriptionId}, UserId: ${userId}`);\n  } catch (error) {\n    console.error('Error handling subscription.updated event:', error);\n    throw error;\n  }\n}\n\n// Handler for subscription.canceled events\nasync function handleSubscriptionCanceled(data: any) {\n  try {\n    const subscriptionId = data.id;\n    \n    // Find the subscription document\n    const subscriptionRef = db.collection('subscriptions').doc(subscriptionId);\n    const subscriptionDoc = await subscriptionRef.get();\n    \n    if (!subscriptionDoc.exists) {\n      console.error(`Subscription ${subscriptionId} not found for cancellation`);\n      return;\n    }\n    \n    const existingData = subscriptionDoc.data();\n    const userId = existingData?.userId;\n    \n    if (!userId) {\n      console.error('No userId associated with subscription:', subscriptionId);\n      return;\n    }\n    \n    const cancellationEffectiveDate = data.effective_from \n      ? new Date(data.effective_from) \n      : admin.firestore.FieldValue.serverTimestamp();\n    \n    // Update subscription document with canceled status\n    await subscriptionRef.set({\n      status: 'canceled',\n      canceledAt: admin.firestore.FieldValue.serverTimestamp(),\n      cancellationEffectiveDate,\n      updatedAt: admin.firestore.FieldValue.serverTimestamp(),\n    }, { merge: true });\n    \n    // Update user's subscription reference\n    const userSubscriptionRef = db.collection('users').doc(userId).collection('subscriptions').doc(subscriptionId);\n    await userSubscriptionRef.set({\n      status: 'canceled',\n      canceledAt: admin.firestore.FieldValue.serverTimestamp(),\n      cancellationEffectiveDate,\n      updatedAt: admin.firestore.FieldValue.serverTimestamp(),\n    }, { merge: true });\n    \n    // Update user document \n    const userRef = db.collection('users').doc(userId);\n    await userRef.set({\n      subscriptionStatus: 'canceled',\n      subscriptionCanceledAt: admin.firestore.FieldValue.serverTimestamp(),\n      lastUpdated: admin.firestore.FieldValue.serverTimestamp()\n    }, { merge: true });\n    \n    console.log(`Subscription canceled in Firestore. SubscriptionId: ${subscriptionId}, UserId: ${userId}`);\n  } catch (error) {\n    console.error('Error handling subscription.canceled event:', error);\n    throw error;\n  }\n}\n\n// Handler for subscription.payment_succeeded events\nasync function handleSubscriptionPaymentSucceeded(data: any) {\n  try {\n    const subscriptionId = data.subscription_id;\n    \n    // Find the subscription document\n    const subscriptionRef = db.collection('subscriptions').doc(subscriptionId);\n    const subscriptionDoc = await subscriptionRef.get();\n    \n    if (!subscriptionDoc.exists) {\n      console.error(`Subscription ${subscriptionId} not found for payment update`);\n      return;\n    }\n    \n    const existingData = subscriptionDoc.data();\n    const userId = existingData?.userId;\n    \n    if (!userId) {\n      console.error('No userId associated with subscription:', subscriptionId);\n      return;\n    }\n    \n    // Create payment record\n    const paymentData = {\n      subscriptionId,\n      paymentId: data.id,\n      amount: data.amount,\n      currency: data.currency,\n      paymentDate: data.event_time ? new Date(data.event_time) : admin.firestore.FieldValue.serverTimestamp(),\n      status: 'succeeded',\n      nextBillDate: data.next_billed_at ? new Date(data.next_billed_at) : null,\n      receiptUrl: data.receipt_url || null,\n      createdAt: admin.firestore.FieldValue.serverTimestamp(),\n    };\n    \n    // Store payment in payments collection\n    const paymentRef = db.collection('users').doc(userId).collection('payments').doc(data.id);\n    await paymentRef.set(paymentData);\n    \n    // Update subscription with latest payment info\n    await subscriptionRef.set({\n      lastPaymentId: data.id,\n      lastPaymentDate: paymentData.paymentDate,\n      nextBillDate: paymentData.nextBillDate,\n      status: 'active', // Ensure status is active when payment succeeds\n      updatedAt: admin.firestore.FieldValue.serverTimestamp(),\n    }, { merge: true });\n    \n    // Update user document\n    const userRef = db.collection('users').doc(userId);\n    await userRef.set({\n      lastPaymentDate: paymentData.paymentDate,\n      hasActiveSubscription: true,\n      subscriptionStatus: 'active',\n      nextBillDate: paymentData.nextBillDate,\n      lastUpdated: admin.firestore.FieldValue.serverTimestamp()\n    }, { merge: true });\n    \n    console.log(`Payment succeeded recorded. PaymentId: ${data.id}, SubscriptionId: ${subscriptionId}, UserId: ${userId}`);\n  } catch (error) {\n    console.error('Error handling subscription.payment_succeeded event:', error);\n    throw error;\n  }\n}\n\n// Handler for subscription.payment_failed events\nasync function handleSubscriptionPaymentFailed(data: any) {\n  try {\n    const subscriptionId = data.subscription_id;\n    \n    // Find the subscription document\n    const subscriptionRef = db.collection('subscriptions').doc(subscriptionId);\n    const subscriptionDoc = await subscriptionRef.get();\n    \n    if (!subscriptionDoc.exists) {\n      console.error(`Subscription ${subscriptionId} not found for failed payment update`);\n      return;\n    }\n    \n    const existingData = subscriptionDoc.data();\n    const userId = existingData?.userId;\n    \n    if (!userId) {\n      console.error('No userId associated with subscription:', subscriptionId);\n      return;\n    }\n    \n    // Create failed payment record\n    const paymentData = {\n      subscriptionId,\n      paymentId: data.id,\n      amount: data.amount,\n      currency: data.currency,\n      paymentDate: data.event_time ? new Date(data.event_time) : admin.firestore.FieldValue.serverTimestamp(),\n      status: 'failed',\n      failureReason: data.error?.message || 'Payment failed',\n      nextRetryDate: data.next_retry_at ? new Date(data.next_retry_at) : null,\n      createdAt: admin.firestore.FieldValue.serverTimestamp(),\n    };\n    \n    // Store failed payment in payments collection\n    const paymentRef = db.collection('users').doc(userId).collection('payments').doc(data.id);\n    await paymentRef.set(paymentData);\n    \n    // Update subscription with payment failure info\n    await subscriptionRef.set({\n      lastFailedPaymentId: data.id,\n      lastFailedPaymentDate: paymentData.paymentDate,\n      paymentFailureReason: paymentData.failureReason,\n      nextRetryDate: paymentData.nextRetryDate,\n      status: 'past_due', // Usually when payment fails, subscription becomes past_due\n      updatedAt: admin.firestore.FieldValue.serverTimestamp(),\n    }, { merge: true });\n    \n    // Update user document\n    const userRef = db.collection('users').doc(userId);\n    await userRef.set({\n      lastFailedPaymentDate: paymentData.paymentDate,\n      subscriptionStatus: 'past_due',\n      lastUpdated: admin.firestore.FieldValue.serverTimestamp()\n    }, { merge: true });\n    \n    console.log(`Payment failure recorded. PaymentId: ${data.id}, SubscriptionId: ${subscriptionId}, UserId: ${userId}`);\n  } catch (error) {\n    console.error('Error handling subscription.payment_failed event:', error);\n    throw error;\n  }\n}\n\n// Helper function to determine userId from subscription data\nasync function getUserIdFromSubscriptionData(data: any): Promise<string | null> {\n  // First try to get from custom_data\n  if (data.custom_data?.userId) {\n    return data.custom_data.userId;\n  }\n  \n  // Then try to find by customer ID\n  const customerId = data.customer_id;\n  if (customerId) {\n    const userQuery = await db.collection('users')\n      .where('paddleCustomerId', '==', customerId)\n      .limit(1)\n      .get();\n      \n    if (!userQuery.empty) {\n      return userQuery.docs[0].id;\n    }\n  }\n  \n  // Finally, try to find by existing subscription\n  const subscriptionId = data.id;\n  if (subscriptionId) {\n    const subscriptionDoc = await db.collection('subscriptions').doc(subscriptionId).get();\n    if (subscriptionDoc.exists && subscriptionDoc.data()?.userId) {\n      return subscriptionDoc.data()?.userId;\n    }\n  }\n  \n  return null;\n}\n\n// Helper function to format subscription data consistently\nfunction formatSubscriptionData(data: any) {\n  const item = data.items?.[0] || {};\n  const price = item.price || {};\n  const product = item.product || {};\n  const billingCycle = data.billing_cycle || {};\n  \n  return {\n    subscriptionId: data.id,\n    customerId: data.customer_id,\n    status: data.status || 'active',\n    planId: product.id || '',\n    planName: product.name || '',\n    priceId: price.id || '',\n    amount: parseFloat(price.unit_price?.amount || '0'),\n    currency: price.unit_price?.currency_code || data.currency_code || 'USD',\n    billingCycle: {\n      interval: billingCycle.interval || 'month',\n      frequency: billingCycle.frequency || 1,\n    },\n    startDate: data.started_at ? new Date(data.started_at) : new Date(),\n    nextBillDate: data.next_billed_at ? new Date(data.next_billed_at) : null,\n    currentPeriod: {\n      start: data.current_billing_period?.starts_at ? new Date(data.current_billing_period.starts_at) : null,\n      end: data.current_billing_period?.ends_at ? new Date(data.current_billing_period.ends_at) : null,\n    },\n    pausedAt: data.paused_at ? new Date(data.paused_at) : null,\n    canceledAt: data.canceled_at ? new Date(data.canceled_at) : null,\n    customData: data.custom_data || {},\n    rawData: process.env.NODE_ENV === 'development' ? data : undefined, // Only store raw data in development\n  };\n}\n\nasync function handleCheckoutCompleted(data: any) {\n  // This event happens when checkout is completed, but before subscription is created\n  const userId = data.custom_data?.userId;\n  const customerId = data.customer?.id;\n  const transactionId = data.id;\n  \n  if (!userId || !customerId) {\n    console.error('Missing required data in checkout_completed event');\n    return;\n  }\n\n  // We won't store the full checkout data in Firebase anymore\n  // Instead, we'll just keep a minimal reference to match with subscription.created events\n  console.log('Checkout completed event received. Waiting for subscription.created event.');\n  \n  // Store minimal reference data in a temporary collection\n  const tempRef = db.collection('pending_subscriptions').doc(transactionId);\n  await tempRef.set({\n    checkoutId: transactionId,\n    customerId,\n    userId,\n    created: admin.firestore.FieldValue.serverTimestamp(),\n    status: 'pending_subscription'\n  });\n  \n  console.log(`Created temporary reference for checkout ${transactionId} for user ${userId}`);\n} "],"names":[],"mappings":"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","debugId":null}}]
}