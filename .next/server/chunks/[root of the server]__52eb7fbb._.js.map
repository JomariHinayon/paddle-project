{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/elevate/newPaddle/src/app/api/webhook/paddle/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport crypto from 'crypto';\nimport admin from 'firebase-admin';\n\n// Helper function to handle private key formatting\n\nconst getFirebaseCredential = () => {\n  if (process.env.FIREBASE_PRIVATE_KEY) {\n    let privateKey = process.env.FIREBASE_PRIVATE_KEY;\n\n    // Option 1: If stored with \\n\n    if (privateKey.includes('\\\\n')) {\n      privateKey = privateKey.replace(/\\\\n/g, '\\n');\n    }\n\n    // Option 2: If stored as base64\n    if (isBase64(privateKey)) {\n      try {\n        privateKey = Buffer.from(privateKey, 'base64').toString('utf-8');\n      } catch (error) {\n        console.error('Error decoding base64 private key:', error);\n        throw new Error('Could not decode base64 Firebase private key.');\n      }\n    }\n\n    // Final check and formatting to ensure PEM structure\n    if (!privateKey.includes('-----BEGIN PRIVATE KEY-----') || !privateKey.includes('-----END PRIVATE KEY-----')) {\n      console.error('Invalid private key format: Missing BEGIN or END markers.');\n      throw new Error('Invalid Firebase private key format.');\n    }\n\n    // Ensure internal newlines for the base64 part\n    const lines = privateKey.split('\\n');\n    const beginLineIndex = lines.findIndex(line => line.includes('-----BEGIN PRIVATE KEY-----'));\n    const endLineIndex = lines.findIndex(line => line.includes('-----END PRIVATE KEY-----'));\n\n    if (beginLineIndex !== -1 && endLineIndex !== -1 && endLineIndex > beginLineIndex + 1) {\n      const keyLines = lines.slice(beginLineIndex + 1, endLineIndex);\n      const formattedKeyLines = keyLines.map(line => line.trim()).join('');\n      let formattedKey = lines.slice(0, beginLineIndex + 1).join('\\n') + '\\n';\n      for (let i = 0; i < formattedKeyLines.length; i += 64) {\n        formattedKey += formattedKeyLines.substring(i, i + 64) + '\\n';\n      }\n      formattedKey += lines.slice(endLineIndex).join('\\n');\n      privateKey = formattedKey.trim(); // Trim any trailing newline\n    }\n\n\n    console.log('Using private key (first 20 chars):', privateKey.substring(0, 20) + '...');\n\n    return admin.credential.cert({\n      projectId: process.env.FIREBASE_PROJECT_ID,\n      clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n      privateKey: privateKey,\n    });\n  }\n\n  throw new Error('Firebase private key not found in environment variables.');\n};\n\n// Helper function to check if a string is likely base64 encoded\nfunction isBase64(str: string) {\n  try {\n    return Buffer.from(str, 'base64').toString('base64') === str;\n  } catch (e) {\n    return false;\n  }\n}\n\n// Initialize Firebase Admin if not already initialized\nif (!admin.apps.length) {\n  admin.initializeApp({\n    credential: getFirebaseCredential(),\n  });\n}\n\nconst db = admin.firestore();\n\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n};\n\nconst verifyPaddleSignature = (rawBody: string, signature: string) => {\n  try {\n    const publicKey = process.env.PADDLE_PUBLIC_KEY;\n    if (!publicKey) {\n      console.error('Paddle public key not configured in environment variables');\n      return false;\n    }\n\n    // For debugging: log the signature received\n    console.log(`Received signature: ${signature}`);\n    \n    // In development/testing mode, you can bypass signature verification\n    if (process.env.NODE_ENV === 'development' && process.env.BYPASS_PADDLE_VERIFICATION === 'true') {\n      console.log('Bypassing signature verification in development mode');\n      return true;\n    }\n\n    // Use the key directly for HMAC calculation - Paddle's simple API uses HMAC-SHA256\n    const hmacHash = crypto.createHmac('sha256', publicKey).update(rawBody).digest('hex');\n    const result = hmacHash === signature;\n    \n    console.log(`Signature verification: ${result ? 'Success' : 'Failed'}`);\n    console.log(`Calculated hash (first 10 chars): ${hmacHash.substring(0, 10)}...`);\n    console.log(`Expected signature (first 10 chars): ${signature.substring(0, 10)}...`);\n\n    return result;\n  } catch (error) {\n    console.error('Error verifying Paddle signature:', error);\n    return false;\n  }\n};\n\nexport async function POST(req: Request) {\n  try {\n    // Read the raw body\n    const rawBody = await req.text();\n    const url = new URL(req.url);\n    \n    // Check if this is a test endpoint\n    if (url.pathname.includes('/test')) {\n      console.log('TEST WEBHOOK - Headers:', JSON.stringify(Object.fromEntries([...req.headers])));\n      console.log('TEST WEBHOOK - Raw Body:', rawBody);\n      \n      try {\n        // Try to parse the body as JSON\n        const jsonBody = JSON.parse(rawBody);\n        console.log('TEST WEBHOOK - Parsed JSON:', JSON.stringify(jsonBody, null, 2));\n      } catch (e) {\n        console.log('TEST WEBHOOK - Not valid JSON');\n      }\n      \n      // Always return success for testing\n      return NextResponse.json({ \n        status: 'success',\n        message: 'Test webhook received and logged'\n      });\n    }\n    \n    // Production webhook handling\n    const signature = req.headers.get('paddle-signature');\n\n    console.log('Incoming webhook payload:', rawBody);\n    console.log('Webhook headers:', JSON.stringify(Object.fromEntries([...req.headers])));\n\n    // During initial setup or troubleshooting, you can temporarily allow webhooks without verification\n    const bypassVerification = process.env.NODE_ENV === 'development' && process.env.BYPASS_PADDLE_VERIFICATION === 'true';\n    \n    if (!signature) {\n      console.error('No paddle-signature header found');\n      return NextResponse.json({ message: 'Missing signature header' }, { status: 401 });\n    }\n    \n    if (!bypassVerification && !verifyPaddleSignature(rawBody, signature)) {\n      console.error('Signature verification failed');\n      \n      // During testing/development, you can still process the webhook even if verification fails\n      if (process.env.NODE_ENV === 'development' && process.env.PROCESS_INVALID_SIGNATURES === 'true') {\n        console.log('Processing webhook despite failed verification (development mode)');\n      } else {\n        return NextResponse.json({ message: 'Invalid signature' }, { status: 401 });\n      }\n    }\n    \n    const { event_type, data } = JSON.parse(rawBody);\n    const normalizedEvent = event_type.replace('.', '_');\n\n    console.log(`Processing Paddle ${event_type} event`, { data: JSON.stringify(data) });\n\n    switch (normalizedEvent) {\n      case 'subscription_created':\n        await handleSubscriptionTransaction(data);\n        break;\n      case 'subscription_updated':\n        await handleSubscriptionTransaction(data);\n        break;\n      case 'subscription_canceled':\n        await handleSubscriptionCancellation(data);\n        break;\n      case 'checkout_completed':\n        await handleCheckoutCompleted(data);\n        break;\n      default:\n        console.log(`Unhandled event type: ${event_type}`);\n    }\n\n    return NextResponse.json({ message: 'Webhook processed' }, { status: 200 });\n  } catch (error) {\n    console.error('Webhook Error:', error);\n    return NextResponse.json({ message: 'Webhook processing failed' }, { status: 400 });\n  }\n}\n\nasync function handleCheckoutCompleted(data: any) {\n  // This event happens when checkout is completed, but before subscription is created\n  const userId = data.custom_data?.userId;\n  const customerId = data.customer?.id;\n  const transactionId = data.id;\n  \n  if (!userId || !customerId) {\n    console.error('Missing required data in checkout_completed event');\n    return;\n  }\n\n  const checkoutData = {\n    checkoutId: transactionId,\n    customerId,\n    userId,\n    status: data.status,\n    completed: true,\n    items: data.items || [],\n    createdAt: admin.firestore.FieldValue.serverTimestamp(),\n    rawData: data\n  };\n\n  // Store the checkout data indexed by checkoutId\n  const checkoutRef = db.collection('checkouts').doc(transactionId);\n  await checkoutRef.set(checkoutData);\n\n  // Also store a reference in the user's collection for easier access\n  const userCheckoutRef = db.collection('users').doc(userId).collection('checkouts').doc(transactionId);\n  await userCheckoutRef.set(checkoutData);\n}\n\nasync function handleSubscriptionTransaction(data: any) {\n  let userId = data.custom_data?.userId;\n  const customerId = data.customer_id;\n  const subscriptionId = data.id;\n  const transactionId = data.transaction_id || subscriptionId;\n\n  if (!userId && customerId) {\n    // Try to find userId from customer ID if not directly provided\n    const userQuery = await db.collection('users')\n      .where('paddleCustomerId', '==', customerId)\n      .limit(1)\n      .get();\n      \n    if (!userQuery.empty) {\n      userId = userQuery.docs[0].id;\n      console.log(`Found userId ${userId} from customerId ${customerId}`);\n    }\n  }\n\n  if (!userId || !customerId) {\n    console.error('Missing required user identification data');\n    return;\n  }\n\n  const item = data.items?.[0];\n  const billingCycle = data.billing_cycle || item?.price?.billing_cycle || {};\n\n  const transactionData = {\n    subscriptionId,\n    customerId,\n    transactionId,\n    status: data.status || 'active',\n    planId: item?.product?.id || '',\n    priceId: item?.price?.id || '',\n    productId: item?.product?.id || '',\n    productName: item?.product?.name || '',\n    quantity: item?.quantity || 1,\n    amountPaid: parseFloat(item?.price?.unit_price?.amount || '0'),\n    currency: item?.price?.unit_price?.currency_code || data.currency_code || 'USD',\n    nextBillDate: data.next_billed_at ? new Date(data.next_billed_at) : null,\n    startDate: data.started_at ? new Date(data.started_at) : new Date(),\n    createdAt: data.created_at ? new Date(data.created_at) : new Date(),\n    updatedAt: data.updated_at ? new Date(data.updated_at) : new Date(),\n    billingCycle: {\n      interval: billingCycle.interval || 'month',\n      frequency: billingCycle.frequency || 1,\n    },\n    customData: data.custom_data || {},\n    customerEmail: data.billing_details?.email || '',\n    addressId: data.address_id || '',\n    discount: data.discount || null,\n    pausedAt: data.paused_at ? new Date(data.paused_at) : null,\n    canceledAt: data.canceled_at ? new Date(data.canceled_at) : null,\n    firstBilledAt: data.first_billed_at ? new Date(data.first_billed_at) : null,\n    currentBillingPeriod: {\n      startsAt: data.current_billing_period?.starts_at ? new Date(data.current_billing_period.starts_at) : null,\n      endsAt: data.current_billing_period?.ends_at ? new Date(data.current_billing_period.ends_at) : null,\n    },\n    collectionMode: data.collection_mode || 'automatic',\n    importMeta: data.import_meta || null,\n    scheduledChange: data.scheduled_change || null,\n  };\n\n  // Store the transaction data in the transactions collection\n  const transRef = db.collection('users').doc(userId).collection('transactions').doc(transactionId);\n  await transRef.set(transactionData, { merge: true });\n\n  // Also update the user document with subscription info\n  const userRef = db.collection('users').doc(userId);\n  await userRef.set({\n    hasActiveSubscription: true,\n    currentSubscriptionId: subscriptionId,\n    subscriptionStatus: data.status || 'active',\n    currentPlan: item?.product?.id || '',\n    nextBillDate: data.next_billed_at ? new Date(data.next_billed_at) : null,\n    paddleCustomerId: customerId,\n    lastTransactionDate: new Date()\n  }, { merge: true });\n}\n\nasync function handleSubscriptionCancellation(data: any) {\n  let userId = data.custom_data?.userId;\n  const customerId = data.customer_id;\n  const subscriptionId = data.id;\n  const transactionId = data.transaction_id || subscriptionId;\n\n  if (!userId && !customerId) {\n    console.error('Missing required user identification data');\n    \n    // Try to find userId from existing transactions\n    if (customerId) {\n      // Lookup all transactions to find one with this customerId\n      const subsQuery = await db.collectionGroup('transactions')\n        .where('customerId', '==', customerId)\n        .limit(1)\n        .get();\n        \n      if (!subsQuery.empty) {\n        // Get the parent path to extract userId\n        const docPath = subsQuery.docs[0].ref.path;\n        const pathParts = docPath.split('/');\n        // Path format: users/{userId}/transactions/{transactionId}\n        if (pathParts.length >= 4 && pathParts[0] === 'users') {\n          userId = pathParts[1];\n          console.log(`Found userId ${userId} from existing transaction for customerId ${customerId}`);\n        }\n      }\n    }\n    \n    if (!userId) {\n      console.error('Cannot process cancellation: No userId found');\n      return;\n    }\n  }\n\n  const cancellationData = {\n    status: 'canceled',\n    canceledAt: data.canceled_at ? new Date(data.canceled_at) : new Date(),\n    updatedAt: new Date(),\n  };\n\n  // Update the transaction record\n  const transRef = db.collection('users').doc(userId).collection('transactions').doc(transactionId);\n  await transRef.set(cancellationData, { merge: true });\n\n  // Update the user's subscription status\n  const userRef = db.collection('users').doc(userId);\n  await userRef.set({\n    hasActiveSubscription: false,\n    subscriptionStatus: 'canceled',\n    subscriptionCanceledAt: admin.firestore.FieldValue.serverTimestamp(),\n  }, { merge: true });\n} "],"names":[],"mappings":"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","debugId":null}}]
}